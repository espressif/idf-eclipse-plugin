/*
 * generated by Xtext 2.28.0
 */
package com.espressif.idf.componen.serializer;

import com.espressif.idf.componen.iDFComponentDsl.COMMENT;
import com.espressif.idf.componen.iDFComponentDsl.COMPONENT_NAME;
import com.espressif.idf.componen.iDFComponentDsl.ComponentModel;
import com.espressif.idf.componen.iDFComponentDsl.DependenciesComp;
import com.espressif.idf.componen.iDFComponentDsl.Description;
import com.espressif.idf.componen.iDFComponentDsl.IDF;
import com.espressif.idf.componen.iDFComponentDsl.IDFComponentDslPackage;
import com.espressif.idf.componen.iDFComponentDsl.OVERRIDE_PATH;
import com.espressif.idf.componen.iDFComponentDsl.PUBLIC;
import com.espressif.idf.componen.iDFComponentDsl.RULES;
import com.espressif.idf.componen.iDFComponentDsl.URL;
import com.espressif.idf.componen.iDFComponentDsl.VersionInfo;
import com.espressif.idf.componen.services.IDFComponentDslGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class IDFComponentDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private IDFComponentDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == IDFComponentDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case IDFComponentDslPackage.COMMENT:
				sequence_COMMENT(context, (COMMENT) semanticObject); 
				return; 
			case IDFComponentDslPackage.COMPONENT_NAME:
				sequence_COMPONENT_NAME(context, (COMPONENT_NAME) semanticObject); 
				return; 
			case IDFComponentDslPackage.COMPONENT_MODEL:
				sequence_ComponentModel(context, (ComponentModel) semanticObject); 
				return; 
			case IDFComponentDslPackage.DEPENDENCIES_COMP:
				sequence_DependenciesComp(context, (DependenciesComp) semanticObject); 
				return; 
			case IDFComponentDslPackage.DESCRIPTION:
				sequence_Description(context, (Description) semanticObject); 
				return; 
			case IDFComponentDslPackage.IDF:
				sequence_IDF(context, (IDF) semanticObject); 
				return; 
			case IDFComponentDslPackage.OVERRIDE_PATH:
				sequence_OVERRIDE_PATH(context, (OVERRIDE_PATH) semanticObject); 
				return; 
			case IDFComponentDslPackage.PUBLIC:
				sequence_PUBLIC(context, (PUBLIC) semanticObject); 
				return; 
			case IDFComponentDslPackage.RULES:
				sequence_RULES(context, (RULES) semanticObject); 
				return; 
			case IDFComponentDslPackage.URL:
				sequence_URL(context, (URL) semanticObject); 
				return; 
			case IDFComponentDslPackage.VERSION_INFO:
				sequence_VersionInfo(context, (VersionInfo) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns COMMENT
	 *     COMMENT returns COMMENT
	 *
	 * Constraint:
	 *     name=ID+
	 * </pre>
	 */
	protected void sequence_COMMENT(ISerializationContext context, COMMENT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Feature returns COMPONENT_NAME
	 *     COMPONENT_NAME returns COMPONENT_NAME
	 *
	 * Constraint:
	 *     (name=ID features+=COMPONENT_NAME_FEATURE*)
	 * </pre>
	 */
	protected void sequence_COMPONENT_NAME(ISerializationContext context, COMPONENT_NAME semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ComponentModel returns ComponentModel
	 *
	 * Constraint:
	 *     elements+=Type+
	 * </pre>
	 */
	protected void sequence_ComponentModel(ISerializationContext context, ComponentModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns DependenciesComp
	 *     DependenciesComp returns DependenciesComp
	 *
	 * Constraint:
	 *     features+=Feature+
	 * </pre>
	 */
	protected void sequence_DependenciesComp(ISerializationContext context, DependenciesComp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns Description
	 *     Description returns Description
	 *
	 * Constraint:
	 *     name=STRING
	 * </pre>
	 */
	protected void sequence_Description(ISerializationContext context, Description semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IDFComponentDslPackage.Literals.DESCRIPTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IDFComponentDslPackage.Literals.DESCRIPTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDescriptionAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Feature returns IDF
	 *     IDF returns IDF
	 *
	 * Constraint:
	 *     name=STRING
	 * </pre>
	 */
	protected void sequence_IDF(ISerializationContext context, IDF semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IDFComponentDslPackage.Literals.FEATURE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IDFComponentDslPackage.Literals.FEATURE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIDFAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Feature returns OVERRIDE_PATH
	 *     OVERRIDE_PATH returns OVERRIDE_PATH
	 *
	 * Constraint:
	 *     name=STRING
	 * </pre>
	 */
	protected void sequence_OVERRIDE_PATH(ISerializationContext context, OVERRIDE_PATH semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IDFComponentDslPackage.Literals.FEATURE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IDFComponentDslPackage.Literals.FEATURE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOVERRIDE_PATHAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     COMPONENT_NAME_FEATURE returns PUBLIC
	 *     PUBLIC returns PUBLIC
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_PUBLIC(ISerializationContext context, PUBLIC semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IDFComponentDslPackage.Literals.COMPONENT_NAME_FEATURE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IDFComponentDslPackage.Literals.COMPONENT_NAME_FEATURE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPUBLICAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     COMPONENT_NAME_FEATURE returns RULES
	 *     RULES returns RULES
	 *
	 * Constraint:
	 *     name=STRING
	 * </pre>
	 */
	protected void sequence_RULES(ISerializationContext context, RULES semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IDFComponentDslPackage.Literals.COMPONENT_NAME_FEATURE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IDFComponentDslPackage.Literals.COMPONENT_NAME_FEATURE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRULESAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns URL
	 *     URL returns URL
	 *
	 * Constraint:
	 *     name=STRING
	 * </pre>
	 */
	protected void sequence_URL(ISerializationContext context, URL semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IDFComponentDslPackage.Literals.URL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IDFComponentDslPackage.Literals.URL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getURLAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns VersionInfo
	 *     VersionInfo returns VersionInfo
	 *
	 * Constraint:
	 *     name=STRING
	 * </pre>
	 */
	protected void sequence_VersionInfo(ISerializationContext context, VersionInfo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IDFComponentDslPackage.Literals.VERSION_INFO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IDFComponentDslPackage.Literals.VERSION_INFO__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVersionInfoAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
